#version 450

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

struct GaussianParam {
    vec3 position;  float opacity;
    vec3 scale;     float _pad0;
    vec4 rotation;
    vec3 color;     float _pad1;
};

// int 버전 (atomic용) - float * 1000000 스케일
struct GaussianGradInt {
    ivec3 dPosition;  int dOpacity;
    ivec3 dScale;     int _pad0;
    ivec4 dRotation;
    ivec3 dColor;     int _pad1;
};

layout(std430, binding = 0) buffer Params   { GaussianParam params[]; };
layout(std430, binding = 1) buffer Grads    { GaussianGradInt grads[]; };
layout(std430, binding = 2) buffer Rendered { vec4 rendered[]; };
layout(std430, binding = 3) buffer Target   { vec4 target[]; };

layout(push_constant) uniform PC {
    uint width;
    uint height;
    uint gaussCount;
} pc;

const float SCALE = 1000000.0;  // float→int 변환 스케일

void main() {
    uint px = gl_GlobalInvocationID.x;
    uint py = gl_GlobalInvocationID.y;
    if (px >= pc.width || py >= pc.height) return;
    
    uint idx = py * pc.width + px;
    vec2 pixelPos = vec2(float(px) + 0.5, float(py) + 0.5);
    vec3 dL_dR = rendered[idx].rgb - target[idx].rgb;
    
    float T = 1.0;
    for (uint i = 0; i < pc.gaussCount; i++) {
        GaussianParam g = params[i];
        
        vec2 center = g.position.xy;
        vec2 diff = pixelPos - center;
        float r2 = dot(diff, diff);
        float sigma2 = g.scale.x * g.scale.x;
        float gaussian = exp(-0.5 * r2 / sigma2);
        float alpha = gaussian * g.opacity;
        
        // dL/dColor
        vec3 dColor = dL_dR * alpha * T;
        atomicAdd(grads[i].dColor.r, int(dColor.r * SCALE));
        atomicAdd(grads[i].dColor.g, int(dColor.g * SCALE));
        atomicAdd(grads[i].dColor.b, int(dColor.b * SCALE));
        
        // dL/dPosition
        vec2 dGauss_dCenter = gaussian * diff / sigma2;
        float dL_dGauss = dot(dL_dR, g.color) * g.opacity * T;
        atomicAdd(grads[i].dPosition.x, int(dL_dGauss * dGauss_dCenter.x * SCALE));
        atomicAdd(grads[i].dPosition.y, int(dL_dGauss * dGauss_dCenter.y * SCALE));
        
        T *= (1.0 - alpha);
        if (T < 0.001) break;
    }
}